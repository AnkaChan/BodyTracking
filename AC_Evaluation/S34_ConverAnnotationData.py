import sys
import json

import LabelMeFileIO
import QuadLabels

import argparse
from pathlib import Path
import glob
import os
import numpy as np
import tqdm
from os.path import join
from matplotlib import pyplot as plt

from QuadProposals.quadprops import *
from S33_Evaluate_EndToEnd_Test import overlapAreaRatio

suit_dict = {'1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, 'A': 7, 'B': 8, 'C': 9, 'D': 10, 'E': 11, 'F': 12,
             'G': 13, 'J': 14,
             'K': 15, 'L': 16, 'M': 17, 'P': 18, 'Q': 19, 'R': 20, 'T': 21, 'U': 22, 'V': 23, 'Y': 24}

def get_vertices(obj):
    """extracts vertices (points) from a labelme-json file"""
    vlist = []
    for i in range(len(obj['shapes'])):
        if obj['shapes'][i]['label'] != 'bound_poly':
            vlist.append(obj['shapes'][i]['points'][0])
    return np.array(vlist)

if __name__ == "__main__":
    # imgFile = r'C:\Code\MyRepo\03_capture\BodyTracking\AC_Evaluation\NewSuit\Annotation\04559_JP.pgm'
    # inCornerLabelFile = r'C:\Code\MyRepo\03_capture\BodyTracking\AC_Evaluation\NewSuit\Annotation\04559_JP_corners.json'
    # inQuadLabelFile = r'C:\Code\MyRepo\03_capture\BodyTracking\AC_Evaluation\NewSuit\Annotation\04559_JP_Code.json'
    inFolder = r'C:\Code\MyRepo\03_capture\BodyTracking\AC_Evaluation\NewSuit\Annotation'
    imgNames = ['04559_JP', '04165_KM']
    imgFiles = [
        join(inFolder, imgName + '.pgm') for imgName in imgNames
    ]
    inCornerLabelFiles = [
        join(inFolder, imgName + '_corners.json') for imgName in imgNames
    ]
    inQuadLabelFiles = [
        join(inFolder, imgName + '_Code.json') for imgName in imgNames
    ]

    outFolder = 'NewSuit/TestData'


    img_list_negative = []
    img_list_positive = []
    labels = []

    for imgName, imgFile, inCornerLabelFile, inQuadLabelFile in zip(imgNames, imgFiles, inCornerLabelFiles, inQuadLabelFiles):
        negativeQuads = []
        positiveQuads = []
        codes_img = []

        # img = cv2.imread(imgFile, cv2.IMREAD_GRAYSCALE)
        img = cv2.imread(imgFile)

        labelSet, _ = LabelMeFileIO.loadLabelMePolygonLabels(inQuadLabelFile)

        qLabelSet = QuadLabels.polygonLabelsToQuad(labelSet, readFlagFromColor=True)
        # json.dump(qLabelSet.__dict__, open(inQuadLabelFile, 'w'), indent=4)
        # print(qLabelSet)
        # QuadLabels.drawQuadLabel(join(outFolder, imgName+ '_QuadAnnotationVisualize.pdf'), qLabelSet, img)

        corners = get_vertices(json.load(open(inCornerLabelFile)))
        #visualize corners here

        # fig, ax = plt.subplots()
        # ax.imshow(img, vmin=0, vmax=255, interpolation='nearest')
        # ax.axis('off')
        # ax.plot(corners[:, 0], corners[:, 1], 'x', color='red', markeredgewidth=0.06, markersize=1)
        # # fig.savefig(join(outFolder, imgName + '_CornerAnnotationVisualize.pdf'), dpi=2000, transparent=True, bbox_inches='tight', pad_inches=0)
        # plt.close()
        # print(corners)

        qps = quad_proposals(corners, min_area=300)

        # Some hand annotated quads were not generated by quad proposal? Why is that? Bugs in generation or matching?
        # this code is for debugging
        annotatedQuadNoMatch = []
        annotatedQuadNoMatchCodes = []
        for code, labeledQI in tqdm.tqdm(zip(qLabelSet.codes, qLabelSet.indices)):
            match=False
            bestOverlapRation = 0
            bestOverlapQpId = -1
            qLabel = [qLabelSet.verts[iV] for iV in labeledQI]

            for qp in qps:
                qGen = [corners[iV, :] for iV in qp]
                overlapRatio = overlapAreaRatio(qGen, qLabel)
                if overlapRatio > 0.95:
                    match = True
                    break
                if bestOverlapRation < overlapRatio:
                    bestOverlapRation = overlapRatio
                    bestOverlapQpId = qp
            if not match:
                print('Annotated quad ', code, ' has no corresponding candidate quad, the best overlapping ration is: ', bestOverlapRation)
                annotatedQuadNoMatch.append(qLabel)
                annotatedQuadNoMatchCodes.append(code)

        # draw all the annotated quad without match
        # fig, ax = plt.subplots()
        # ax.imshow(img, vmin=0, vmax=255, interpolation='nearest', cmap=plt.get_cmap('gray'))
        # pts = np.array(qLabelSet.verts)
        # for i, (q, code) in enumerate(zip(annotatedQuadNoMatch, annotatedQuadNoMatchCodes)):
        #     x_coords = [q[0][0], q[1][0], q[2][0], q[3][0], q[0][0]]
        #     y_coords = [q[0][1], q[1][1], q[2][1], q[3][1], q[0][1]]
        #     ax.plot(x_coords, y_coords, '-', linewidth=0.02, color='red')
        #     ax.text(np.mean(x_coords[0:4]), np.mean(y_coords[0:4]), code, \
        #             verticalalignment='center', horizontalalignment='center', fontsize=1, color='green')
        #     ax.text(x_coords[0], y_coords[0], '0', verticalalignment='top', horizontalalignment='left', fontsize=0.3,
        #             color='red')
        # fig.savefig(join(outFolder, imgName + '_AnnotQuadsWOMatch.pdf'), dpi=2000)
        # plt.close()

        # qp does not include all 4 orientations
        for qp in tqdm.tqdm(qps):
            match=False
            for code, labeledQI in zip(qLabelSet.codes, qLabelSet.indices):
                qLabel = [qLabelSet.verts[iV] for iV in labeledQI]
                qGen = [corners[iV, :] for iV in qp]
                if overlapAreaRatio(qGen, qLabel) > 0.95:
                    positiveQuads.append(qLabel)
                    codes_img.append(code.upper())
                    match=True

                    # wimg1 = warped_subimage(img, np.array(qLabel))
                    # wimg2 = warped_subimage(img, np.array(qGen))
                    #
                    # cv2.imshow('NPositiveExmp: qLabel', wimg1)
                    # cv2.imshow('NPositiveExmp: qGen', wimg2)
                    # cv2.waitKey()

                    break

            if not match:
                negativeQuads.append(qGen)

        print('Number of negative quads: ', len(negativeQuads))
        print('Number of positive quads: ', len(positiveQuads))

        corners = np.array(corners)
        for _, qv_img in enumerate(negativeQuads):
            # qv_img = corners[item, :]
            wimg = warped_subimage(img, np.array(qv_img))
            img_list_negative.append(wimg)
        #
        #     cv2.imshow('NegativeExmp', wimg)
        #     cv2.waitKey()
        #
        for iPosImg, qv_img in enumerate(positiveQuads):
            # qv_img = corners[item, :]
            wimg = warped_subimage(img, np.array(qv_img))
            img_list_positive.append(wimg)

            code = codes_img[iPosImg]
            label = [suit_dict[code[0]], suit_dict[code[1]]]
            labels.append(label)
            # cv2.imshow('PositiveExmp', wimg)
            # print('code: ', code)
            # cv2.waitKey()



    labels_Rejector = np.array([[0] for _ in img_list_negative] + [[1] for _ in img_list_positive])
    imgsAll = np.array(img_list_negative + img_list_positive)

    print('imgsAll.shape', imgsAll.shape)
    print('labels.shape', labels_Rejector.shape)

    np.save(join(outFolder, 'Imgs_RejectorNet.npy'), imgsAll)
    np.save(join(outFolder, 'Labels_RejectorNet.npy'), labels_Rejector)

    np.save(join(outFolder, 'Imgs_RecogNet.npy'), img_list_positive)
    np.save(join(outFolder, 'Labels_RecogNet.npy'), labels)




